from __future__ import print_function, division

__author__ = 'saeedamen'  # Saeed Amen / saeed@cuemacro.com

#
# Copyright 2018 Cuemacro Ltd. - http//www.cuemacro.com / @cuemacro
#
# See the License for the specific language governing permissions and limitations under the License.
#

import pandas as pd
import numpy as np

import copy

from tcapy.conf.constants import Constants
from tcapy.util.loggermanager import LoggerManager
from tcapy.util.timeseries import TimeSeriesOps
from tcapy.util.utilfunc import UtilFunc

try:
    from StringIO import StringIO
except ImportError:
    from io import StringIO

# use a modified version of Plotly's figure_factory (which is much quicker with pd/NumPy data)
import tcapy.vis.candlestick as figure_factory

from tcapy.analysis.algos.metric import MetricWideBenchmarkMarkout

import dash_html_components as html

import dash

from chartpy import Chart, Style

from collections import OrderedDict

# from plotly import figure_factory

constants = Constants()

class DisplayListeners(object):
    """Creates listeners for the display components of our dash applications, such as plots and tables. Hence, it attaches
    event code to them.

    It currently supports, markout style components, timeline components, download CSV components, distribution style components

    Also has methods to handle the callbacks for these components to be updated, fetching the appropriate DataFrames
    from TCA analysis (which have been generated by the TCACaller/TCAEngine classes). Then uses PlotRender to convert the
    DataFrames to plotly.Fig objects which can be displayed natively by Dash.

    """

    def __init__(self, app, layout, session_manager, callback_manager, tca_caller, css, url_prefix):

        self._layout = layout  # HTML/Dash layout for each page of the application
        self._session_manager = session_manager  # handling user session data
        self._callback_manager = callback_manager  # for creating Dash callbacks for Dash components
        self._tca_caller = tca_caller  # for triggering TCA calculations and converting GUI input

        self._plot_render = PlotRender(css)  # for converting DataFrames to plotly.Fig
        self._util_func = UtilFunc()  # for utility function such as flattening lists
        self._time_series_ops = TimeSeriesOps()  # basic time series operations

        self._metric_wide = MetricWideBenchmarkMarkout()

        # create callbacks for each display component (plots/tables) in every page of the application
        self.create_callbacks(app, layout, callback_manager)

        self._url_prefix = url_prefix

    def plot_candle_timeline(self, trade_order, trade_order_tag, tca_type):
        """Collects the DataFrame for a market/candlestick plot, alongside the trade/orders, when a callback has been
        triggered (usually the end of at TCA computation). Then uses PlotRender to convert into a plotly.Fig.

        Parameters
        ----------
        trade_order : str
            Trade/order description (eg. 'execution' or 'order')

        trade_order_tag : str
            DataFrame to fetch from catch (eg. sparse_market_order_df)

        tca_type : str
            Type of TCA (eg. 'detailed')

        Returns
        -------
        plotly.Fig
        """

        # Callback triggered by Dash application
        def callback(lines_to_plot, relayoutData, _):
            logger = LoggerManager.getLogger(__name__)

            # Only draw if lines have been selected!
            if lines_to_plot != [] and self._session_manager.exists_session_tag(tca_type + '-title') and \
                self._session_manager.check_session_tag(tca_type + '-visualization'):

                if 'execution' in trade_order:
                    print('execution')

                # TODO sort out refiring of box
                redraw_plot = self._session_manager.get_session_flag(
                        'redraw-' + tca_type + '-' + trade_order + '-candle-timeline-plot')

                lines_drawn = (self._session_manager.check_lines_plotted(lines_to_plot,
                                    tca_type + '-' + trade_order + '-candle-timeline-plot-lines-old'))

                # lines_drawn = True

                relayoutData_drawn = (self._session_manager.check_relayoutData_plotted(relayoutData,
                                    tca_type + '-' + trade_order + '-candle-timeline-plot-lines-relayoutData-old'))

                # Only redraw if the underlying data has already been rendered (check by looking all the flags)
                if redraw_plot or not(lines_drawn) or not(relayoutData_drawn):

                    # Special case: if we have pressed calculate button, ignore any zooming in from previous instance
                    # ignore the relayoutData variable, which is not reset
                    if self._session_manager.get_session_flag(
                            'redraw-' + tca_type + '-' + trade_order + '-candle-timeline-plot') \
                            and (self._session_manager.check_relayoutData_plotted(relayoutData,
                                                                                  tca_type + '-' + trade_order + '-candle-timeline-plot-lines-relayoutData-old')):
                        relayoutData = None

                    self._session_manager.set_session_flag(
                        'redraw-' + tca_type + '-' + trade_order + '-candle-timeline-plot', False)

                    # Save the lines plotted and also the relayoutData
                    self._session_manager.set_session_flag(
                        tca_type + '-' + trade_order + '-candle-timeline-plot-lines-old', lines_to_plot)
                    self._session_manager.set_session_flag(
                        tca_type + '-' + trade_order + '-candle-timeline-plot-lines-relayoutData-old', relayoutData)

                    #self._session_manager.set_lines_plotted(lines_to_plot,
                    #    tca_type + '-' + trade_order + '-candle-timeline-plot-lines-old')
                    #self._session_manager.set_relayoutData_plotted(relayoutData,
                    #    tca_type + '-' + trade_order + '-candle-timeline-plot-lines-relayoutData-old')

                    # eg. 'sparse_market_trade_df'
                    market_df, candlestick_fig = self._tca_caller.get_cached_computation_analysis(
                       key=[trade_order_tag, 'candlestick_fig'])

                    # candlestick_fig = None
                    # market_df= self._tca_caller.get_cached_tca_analysis(
                    #     key=[trade_order_tag])

                    # If user has zoomed window, re-render candlesticks with appropriate granularity
                    if relayoutData is not None:

                        custom_scaling = False

                        # Check autosize first (if autosize, we can use the cached candlestick figure object)
                        if 'autosize' in relayoutData:
                            if relayoutData['autosize'] == True:
                                custom_scaling = False
                        else:
                            custom_scaling = True

                        # In that case we need to create a customised candlestick plot, with user defined start/finish
                        if custom_scaling:
                            market_full_df = self._tca_caller.get_cached_computation_analysis(key=['market_df'])

                            if market_full_df is not None:
                                if not(market_full_df.empty):

                                    start_date = market_full_df.index[0];
                                    finish_date = market_full_df.index[-1]

                                    try:
                                        relayoutData_start = pd.Timestamp(relayoutData['xaxis.range[0]']).tz_localize('utc')
                                        relayoutData_finish = pd.Timestamp(relayoutData['xaxis.range[1]']).tz_localize(
                                            'utc')

                                        if relayoutData_start < relayoutData_finish:
                                            if relayoutData_start > start_date and relayoutData_start < finish_date:
                                                start_date = relayoutData_start

                                            if relayoutData_finish > start_date and relayoutData_finish < finish_date:
                                                finish_date = relayoutData_finish

                                    except Exception as e:
                                        print(str(e))

                                    candlestick_fig = self._plot_render.generate_candlesticks(
                                        self._time_series_ops.downsample_time_series_usable(
                                            market_full_df, start_date=start_date, finish_date=finish_date))

                            # market_df = time_series_ops.filter_between_dates(market_df, start_date, finish_date)

                    if market_df is not None:
                        if not(market_df.empty):

                            #if 'child' in trade_order:
                            #    return ""

                            return self._plot_render.plot_market_trade_timeline(
                                self._session_manager.get_session_flag(tca_type + '-title'), market_df,
                                lines_to_plot=lines_to_plot, candlestick_fig=candlestick_fig, relayoutData=relayoutData,
                                debug_msg=tca_type + '-' + trade_order + '-title')

                    logger.warn("Line not fetched " + trade_order + ' ' + trade_order_tag)

            # Not very elegant but only way to prevent plots disappearing, when the user hasn't changed the data
            # https://community.plot.ly/t/improving-handling-of-aborted-callbacks/7536/6
            raise dash.exceptions.PreventUpdate("No data changed - candle_timeline")

        return callback

    def plot_markout(self, trade_order_tag, tca_type):
        """Fetches trade/order DataFrame and truncated around clicked trade. Uses PlotRender to convert to plotly.Fig
        ready for display by Dash.

        Parameters
        ----------
        trade_order_tag : str
            Which trade/order dataframe to plot (eg. 'trade_df')

        tca_type : str
            Type of TCA analysis (eg. 'detailed')

        Returns
        -------
        plotly.Fig

        """

        # Callback triggered by Dash application
        def callback(clickData, _):

            if clickData is not None:
                logger = LoggerManager.getLogger(__name__)

                # Collect the markout data for that specific trade point
                market_df, trade_order_df = self._tca_caller.get_cached_computation_analysis(key=['market_df', trade_order_tag])

                # The last point is the 'trade' point
                try:
                    date_val = clickData['points'][-1]['x']
                except:
                    return ""

                date_val_dt = self._util_func.parse_datetime(str(date_val))
                date_val_dt = pd.Timestamp(date_val_dt).tz_localize('utc')

                closest_index = self._time_series_ops.closest_date_index(trade_order_df, date_val_dt)

                trade_df = None

                if closest_index < len(trade_order_df.index) and closest_index >= 0:

                    # Select only the single trade which matches the trade time (is closest)
                    trade_df = pd.DataFrame(trade_order_df.iloc[closest_index, :])

                if trade_df is not None:
                    if not(trade_df.empty):

                        trade_df = trade_df.transpose()

                        # Result will be a plot of the average drift versus the move around the trades we want
                        metric_trade_df, metric_df = \
                            self._metric_wide.calculate_metric(
                                trade_df, market_df, bid_benchmark='bid', ask_benchmark='ask', wide_benchmark='mid')

                        markout_detail_df = metric_df.transpose()

                        return self._plot_render.plot_markout(markout_detail_df,
                                                              self._session_manager.get_session_flag(tca_type + '-title'))

                logger.warn("Couldn't find a markout point for " + str(date_val_dt) + " with closest index " + str(closest_index))

            raise dash.exceptions.PreventUpdate("No data changed - markout") # not very elegant but only way to prevent plots disappearing

        return callback

    def plot_bar(self, trade_order, trade_order_tag, tca_type):
        """Fetches DataFrame to be displayed as a bar chart.

        Parameters
        ----------
        trade_order : str
            Which trade/order to focus on (eg. 'execution-by-ticker)

        trade_order_tag : str
            DataFrame tag to fetch (eg. 'bar_trade_df_by_ticker)

        tca_type : str
            Type of TCA (eg. 'detailed)

        Returns
        -------
        plotly.Fig
        """

        # Callback triggered by Dash application
        def callback(_):
            # make sure all the parameters have been selected
            if self._session_manager.check_session_reset_tag('redraw-' + tca_type + '-' + trade_order + '-bar-plot'):
                key, _, _ = self._create_df_dictionary_key(trade_order_tag)

                # print(key)

                return self._plot_render.plot_bar(
                    title=self._session_manager.get_session_flag(tca_type + '-title'),
                    bar_df=self._tca_caller.get_cached_computation_analysis(key=key))

            raise dash.exceptions.PreventUpdate("No data changed - bar") # not very elegant but only way to prevent plots disappearing

        return callback

    def plot_timeline(self, trade_order, trade_order_tag, tca_type):
        """Timeline to be fetched from the cache and plotted relating to a particular type of analysis on a trade/order,
        using a PlotRender object.

        Parameters
        ----------
        trade_order : str
            Which trade/order does it refer to (eg. 'execution-by-ticker')

        trade_order_tag : str
            The DataFrame we need to fetch (eg. 'timeline_trade_df_by_ticker')

        tca_type : str
            Type of TCA (eg. 'aggregated)

        Returns
        -------
        plotly.Fig
        """

        # Callback triggered by Dash application
        def callback(_):

            # Make sure all the parameters have been selected
            if self._session_manager.check_session_reset_tag(
                    'redraw-' + tca_type + '-' + trade_order + '-timeline-plot'):
                key, _, _ = self._create_df_dictionary_key(trade_order_tag)

                return self._plot_render.plot_timeline(
                    title=self._session_manager.get_session_flag(tca_type + '-title'),
                    timeline_df=self._tca_caller.get_cached_computation_analysis(key=key))

            raise dash.exceptions.PreventUpdate("No data changed timeline") # not very elegant but only way to prevent plots disappearing

        return callback

    def plot_dist(self, trade_order, trade_order_tag, tca_type):
        """Distribution to be fetched and plotted relating to a particular type of analysis on a trade/order.

        Parameters
        ----------
        trade_order : str
            Which trade/order does it refer to (eg. 'execution-by-ticker')

        trade_order_tag : str
            The DataFrame we need to fetch (eg. 'dist_trade_df_by_ticker')

        tca_type : str
            Type of TCA (eg. 'aggregated)

        Returns
        -------
        plotly.Fig
        """

        # Callback triggered by Dash application
        def callback(_):
            # Make sure all the parameters have been selected
            if self._session_manager.check_session_reset_tag('redraw-' + tca_type + '-' + trade_order + '-dist-plot'): # and \
                # self._session_manager.check_session_tag(tca_type + '-visualization'):

                key, metric, split_by = self._create_df_dictionary_key(trade_order_tag)

                # raise dash.exceptions.PreventUpdate("No data changed - dist")
                return self._plot_render.plot_dist(
                    dist_df=self._tca_caller.get_cached_computation_analysis(key=key),
                    metric=metric, title=self._session_manager.get_session_flag(tca_type + '-title'), split_by=split_by)

            raise dash.exceptions.PreventUpdate("No data changed - dist") # not very elegant but only way to prevent plots disappearing

        return callback

    def render_table(self, trade_order, trade_order_tag, tca_type):
        """Renders an HTML table for a particular type of analysis on a trade/order.

        Parameters
        ----------
        trade_order : str
            Which trade/order does it refer to (eg. 'execution-by-ticker')

        trade_order_tag : str
            The DataFrame we need to fetch (eg. 'table_trade_df_markout_by_all')

        tca_type : str
            Type of TCA (eg. 'aggregated)

        Returns
        -------
        str (HTML)
        """

        # Callback triggered by Dash application
        def callback(_):
            if self._session_manager.check_session_reset_tag('redraw-' + tca_type + '-' + trade_order + '-table'): # and \
                # self._session_manager.check_session_tag(tca_type + '-visualization'):

                # if not (self._session_manager.check_session_tag('visualization')): return None

                key, _, _ = self._create_df_dictionary_key(trade_order_tag)

                df = self._tca_caller.get_cached_computation_analysis(key=key)

                if df is not None:
                    return self._plot_render.generate_table(df)

            raise dash.exceptions.PreventUpdate("No data changed - table")

        return callback

    def serve_csv(self, trade_order, trade_order_tag, tca_type):#, chart_type):
        """Creates a link to download CSV file of TCA based analysis

        Parameters
        ----------
        trade_order : str
            Which trade/order does it refer to (eg. 'execution-by-ticker')

        trade_order_tag : str
            The DataFrame we need to fetch (eg. 'table_trade_df_markout_by_all')

        tca_type : str
            Type of TCA (eg. 'aggregated)

        Returns
        -------
        str (HTML)
        """

        # Callback triggered by Dash application
        def callback(_):
            if self._session_manager.check_session_reset_tag('redraw-' + tca_type + '-' + trade_order + '-download-link'):

                if self._url_prefix == '':
                    return '/urlToDownload?dataFrame={}'.format(trade_order_tag)

                return '/' + self._url_prefix + '/urlToDownload?dataFrame={}'.format(trade_order_tag)
                # return self._plot_render.convert_df_csv(self._tca_caller.get_cached_tca_analysis(key=trade_order_tag))

            raise dash.exceptions.PreventUpdate("No data changed - serve csv")

        return callback

    def create_df_as_csv_string(self, trade_order_tag):
        """Fetches a DataFrame from memory (ie. Redis), which has been precomputed for the current user and then
        streams as a string so it can be downloaded as a CSV when clicking on a browser link

        Parameters
        ----------
        trade_order_tag : str
            Tag of the DataFrame to collect

        Returns
        -------
        str
        """
        df_csv = self._plot_render.convert_df_csv(self._tca_caller.get_cached_computation_analysis(key=trade_order_tag))

        strIO = StringIO()
        strIO.write(df_csv)
        strIO.seek(0)

        return strIO

    def _create_df_dictionary_key(self, trade_order_tag):
        """Breaks down a trade/order tag, into the tag, metric and how it should be partitioned.

        Parameters
        ----------
        trade_order_tag : str
            Usually refers to the underlying key in the DataFrame cache

        Returns
        -------
        str, str, str
        """

        t = trade_order_tag.split('_by_')

        metric = '';
        by_partition = ''

        # Handle those cases where metrics are specified on the fly (eg. user specified metric)
        if 'df_by' in trade_order_tag:
            metric = self._session_manager.get_session_flag('metric')
            return t[0] + '_' + metric + '_by_' + t[1], metric, t[1]

        # These instances, the metrics have been hardcoded in, before runtime
        try:
            metric = t[0].split('_df_')[1];
        except:
            pass

        try:
            by_partition = t[1]
        except:
            pass

        return trade_order_tag, metric, by_partition

    ##### click/change callback listeners on each plot, table component etc. ###########################################

    def create_callbacks(self, app, layout, callback_manager):
        """Create input/output callbacks for each display component (plot/table) on each page of the Dash application,
        associating appropriate GUI input/outputs, to trigger a particular method in this class.

        Parameters
        ----------
        app : dash.App
            Dash application (wraps around Flask mini webserver)

        layout : Layout
            HTML/Dash layout of the application

        callback_manager : CallbackManager
            Wrapper for creating Input/Output callbacks over Dash components

        Returns
        -------
        """

        ##### For each page, add dash listeners for each display plot, display table etc.
        for p in self._util_func.dict_key_list(layout.pages.keys()):

            # viz_id = "-visualization-val"

            ## Timelines with candlesticks plots
            key = p + '_candle_timeline_trade_order'

            if key in self._util_func.dict_key_list(layout.id_flags.keys()):
                for t in self._util_func.dict_key_list(layout.id_flags[key].keys()):
                    app.callback(
                        callback_manager.output_callback(p, t + '-candle-timeline-plot'),
                        callback_manager.input_callback(p, [t + '-candle-timeline-plot-lines-val',
                                                            t + '-candle-timeline-plot:relayoutData', 'status'])
                    )(self.plot_candle_timeline(t, layout.id_flags[key][t], p))

            ## Markout plots
            key = p + '_markout_trade_order'

            if key in self._util_func.dict_key_list(layout.id_flags.keys()):
                for t in self._util_func.dict_key_list(layout.id_flags[key].keys()):
                    app.callback(
                        callback_manager.output_callback(p, t + '-markout-plot'),
                        callback_manager.input_callback(p, [t + '-candle-timeline-plot:clickData', 'status'])
                    )(self.plot_markout(layout.id_flags[key][t], p))

            ## Distribution plots
            key = p + '_dist_trade_order'

            if key in self._util_func.dict_key_list(layout.id_flags.keys()):
                for t in self._util_func.dict_key_list(layout.id_flags[key].keys()):
                    app.callback(
                        callback_manager.output_callback(p, t + '-dist-plot'),
                        callback_manager.input_callback(p, 'status')
                    )(self.plot_dist(t, layout.id_flags[key][t], p))

            ## Markout tables
            key = p + '_table_trade_order'

            if key in self._util_func.dict_key_list(layout.id_flags.keys()):
                for t in self._util_func.dict_key_list(layout.id_flags[key].keys()):
                    app.callback(
                        callback_manager.output_callback(p, t + '-table'),
                        callback_manager.input_callback(p, ['status'])
                    )(self.render_table(t, layout.id_flags[key][t], p))

            ## CSV download links
            key = p + '_download_link_trade_order'

            if key in self._util_func.dict_key_list(layout.id_flags.keys()):
                for t in self._util_func.dict_key_list(layout.id_flags[key].keys()):
                    app.callback(
                        callback_manager.output_callback(p, t + '-download-link'),
                        callback_manager.input_callback(p, 'status')
                    )(self.serve_csv(t, layout.id_flags[key][t], p))#, 'candle-timeline'))

            ## Trade/order timeline plots (without candlesticks)
            key = p + '_timeline_trade_order'

            if key in self._util_func.dict_key_list(layout.id_flags.keys()):
                for t in self._util_func.dict_key_list(layout.id_flags[key].keys()):
                    app.callback(
                        callback_manager.output_callback(p, t + '-timeline-plot'),
                        callback_manager.input_callback(p, 'status')
                    )(self.plot_timeline(t, layout.id_flags[key][t], p))

            # Bar plots
            key = p + '_bar_trade_order'

            if key in self._util_func.dict_key_list(layout.id_flags.keys()):
                for t in self._util_func.dict_key_list(layout.id_flags[key].keys()):
                    app.callback(
                        callback_manager.output_callback(p, t + '-bar-plot'),
                        callback_manager.input_callback(p, 'status')
                    )(self.plot_bar(t, layout.id_flags[key][t], p))

            # Metric tables
            key = p + '_metric_table_trade_order'

            if key in self._util_func.dict_key_list(layout.id_flags.keys()):
                for t in self._util_func.dict_key_list(layout.id_flags[key].keys()):
                    app.callback(
                        callback_manager.output_callback(p, t + '-table'),
                        callback_manager.input_callback(p, ['status'])
                    )(self.render_table(t, layout.id_flags[key][t], p))


class PlotRender(object):
    """PlotRender helper class taking in DataFrames, which have been generated in the course of TCA analysis.
    It then specifies various style based properties (like colors, dashs, title etc.) renders these as charts (using chartpy/Plotly as
    dependency). The rendered charts are plotly.Fig objects which can be displayed by a Dash web application, or can be
    rendered in HTML files elsewhere.

    It supports a number of basic chart types such as
     - markouts
     - timelines (with candlesticks)
     - bar charts
     - distribution charts

    """

    def __init__(self, css=''):
        # self.logger = LoggerManager.getLogger(__name__)
        self._chart = Chart(engine='plotly')
        self._time_series_ops = TimeSeriesOps()
        self._util_func = UtilFunc()
        self._metric_wide_benchmark_markout = MetricWideBenchmarkMarkout()

        self._default_chart_width = constants.chart_width
        self._default_chart_height = constants.chart_height
        self._css = css

    def _check_empty(self, df):
        if df is None:
            raise dash.exceptions.PreventUpdate("No data changed - empty plot")

        if df is []:
            raise dash.exceptions.PreventUpdate("No data changed - empty plot")

        if df.empty:
            raise dash.exceptions.PreventUpdate("No data changed - empty plot")


    def plot_markout(self, markout_detail_df, title, width=constants.chart_width, height=constants.chart_height):
        """Renders a plot for a markout around a pre-specified time point.

        Parameters
        ----------
        markout_detail_df : DataFrame
            Time series of price action around markout time

        title : str
            Title of the plot

        width : int
            Width of plot

        height : int
            Height of plot

        Returns
        -------
        plotly.Fig
        """
        logger = LoggerManager.getLogger(__name__)

        self._check_empty(markout_detail_df)

        style = Style(title=title,
                      subplots=False,
                      color=['blue', 'black'],
                      linewidth=[3, 0.5], y_axis_2_series=['Avg Drift'], y_axis_2_showgrid=False,
                      y_axis_showgrid=False,
                      y_title='Cumulative Move (bp)',
                      x_title='Timeline (' + constants.wide_benchmark_unit_of_measure + ')',
                      line_shape=['hv', 'linear'],
                      width=width, height=height, scale_factor=1,
                      plotly_plot_mode=constants.plotly_plot_mode,
                      plotly_webgl=constants.plotly_webgl
                      )

        markout_detail_df.index = [x.replace(constants.wide_benchmark_unit_of_measure, '')
                                   for x in markout_detail_df.index]

        pts = str(len(markout_detail_df.index) * (len(markout_detail_df.columns) + 1))

        logger.debug('Plotting markout ' + pts)

        try:
            plot = self._chart.plot(markout_detail_df, style=style, chart_type=['line', 'line'])

            logger.debug('Rendered markout ' + pts)

            return plot
        except Exception as e:
            logger.debug('No data for printing detail markout plot: ' + str(e))

    def plot_market_trade_timeline(self, title, sparse_market_trade_df, lines_to_plot=constants.detailed_timeline_plot_lines,
                                   candlestick_fig=None,
                                   relayoutData=None, debug_msg='', width=constants.chart_width, height=constants.chart_height):
        """Plots market data as lines on chart (or summarised into candlesticks), accompanied by trade data as bubbles
        which have been scaled by size (and color coded for buys/sells)

        Parameters
        ----------
        title : str
            Title for the plot

        sparse_market_trade_df : DataFrame
            Sparse market data and trade data

        lines_to_plot : str (list)
            Which lines to plot on the chart?

        candlestick_fig : plotly.Fig
            Candlestick plotly Fig to render

        relayoutData : dict
            Contains details of any user zooming

        width : int
            Width of plot

        height : int
            Height of plot

        Returns
        -------
        plotly.Fig
        """
        logger = LoggerManager.getLogger(__name__)

        self._check_empty(sparse_market_trade_df)

        sparse_market_trade_df.columns = [x.replace('_', ' ') for x in sparse_market_trade_df.columns]

        x_axis_range = None
        y_axis_range = None

        # Select range according to user zooming
        if relayoutData is not None:
            try:
                start_date = relayoutData['xaxis.range[0]']
                finish_date = relayoutData['xaxis.range[1]']

                x_axis_range = [start_date, finish_date]
                y_axis_range = [relayoutData['yaxis.range[0]'], relayoutData['yaxis.range[1]']]
            except:
                pass

            # {u'yaxis.autorange': True, u'xaxis.autorange': True}

        # lines_to_get = util_func.flatten_list_of_strings([lines_to_plot, 'notional'])

        notional_series = sparse_market_trade_df['notional']

        # Collect the lines to be plotted, and associate the colors, linewidths, styles with each
        # these default values can be changed in the Constants file
        lines_dict = copy.copy(constants.detailed_timeline_plot_lines)

        # If it's a dict, just take the keys
        if isinstance(lines_to_plot, dict):
            lines_to_plot = self._util_func.dict_key_list(lines_to_plot.keys())

        # Remove any lines not there!
        # optional_lines = ['bid', 'ask', 'vwap', 'twap']

        line_indices_to_remove = []

        for k in lines_to_plot:

            if k not in sparse_market_trade_df.columns and k != 'candlestick':
                if k in lines_dict.keys():
                    lines_dict.pop(k)

                if k in lines_to_plot:
                    line_indices_to_remove.append(lines_to_plot.index(k))
                    # print("Remove " + k)

        lines_to_plot = np.delete(lines_to_plot, line_indices_to_remove).tolist()

        # lines_to_plot.remove('buy trade')
        # lines_to_plot.remove('sell trade')

        candlestick_series = None

        # Should we plot candlestick too? Requires a different flag
        if 'candlestick' in lines_to_plot:
            if candlestick_fig is None:

                candlestick_series = {'open': sparse_market_trade_df['open'],
                                      'high': sparse_market_trade_df['high'],
                                      'low': sparse_market_trade_df['low'],
                                      'close': sparse_market_trade_df['close']}
            else:
                candlestick_series = candlestick_fig

            lines_to_plot.remove('candlestick')

        sparse_market_trade_df = sparse_market_trade_df[lines_to_plot]

        color_list = []
        linewidth_list = []
        chart_type_list = []
        line_shape_list = []

        for i in range(0, len(lines_to_plot)):
            if lines_to_plot[i] in self._util_func.dict_key_list(lines_dict.keys()):
                e = lines_dict[lines_to_plot[i]]

                color_list.append(e['color'])
                linewidth_list.append(e['linewidth'])
                chart_type_list.append(e['chart_type'])

                try:
                    line_shape_list.append(e['line_shape'])
                except:
                    line_shape_list.append(None)

        style = Style(title=title,
                      subplots=False,
                      color=color_list,
                      linewidth=linewidth_list, connect_line_gaps=True, bubble_series={'buy trade': notional_series,
                                                                                       'sell trade': notional_series},
                      line_shape=line_shape_list,
                      bubble_size_scalar=constants.bubble_size_scalar,

                      # Candlestick style parameters
                      candlestick_series=candlestick_series,
                      x_axis_range=x_axis_range, y_axis_range=y_axis_range,
                      candlestick_increasing_color=constants.candlestick_increasing_color,
                      candlestick_increasing_line_color=constants.candlestick_increasing_line_color,
                      candlestick_decreasing_color=constants.candlestick_decreasing_color,
                      candlestick_decreasing_line_color=constants.candlestick_decreasing_line_color,

                      # Control how it is displayed
                      plotly_plot_mode=constants.plotly_plot_mode,
                      width=width, height=height, scale_factor=1,
                      plotly_webgl=constants.plotly_webgl
                      )

        pts = str(len(sparse_market_trade_df.index) * (len(sparse_market_trade_df.columns) + 1))

        logger.debug('Plotting main timeline ' + pts)

        sparse_market_trade_df.columns = [x.replace('_', ' ') for x in sparse_market_trade_df.columns]

        if sparse_market_trade_df.empty:
            print('stop')

        # print(sparse_market_trade_df)
        plot = self._chart.plot(sparse_market_trade_df, style=style, chart_type=chart_type_list)

        logger.debug('Rendered plot ' + pts + ' and ' + debug_msg)

        # Return a plotly.Fig object, which can be displayed by dash
        return plot

    def plot_timeline(self, timeline_df=None, title=None, width=constants.chart_width, height=constants.chart_height):
        """Renders a time series into a plotly Fig object, which can be displayed.

        Parameters
        ----------
        timeline_df : DataFrame
            Time series to be plotted

        title : str
            Title of the plot

        width : int
            Width of plot

        height : int
            Height of plot

        Returns
        -------
        plotly.Fig
        """

        self._check_empty(timeline_df)

        if constants.timeline_fillna is not 'nofill':
            if constants.timeline_fillna == 'ffill':
                timeline_df = timeline_df.fillna(method='ffill')
            if constants.timeline_fillna == 'zero':
                timeline_df = timeline_df.fillna(0)
            else:
                timeline_df = timeline_df.interpolate(method=constants.timeline_fillna)

        return self._chart.plot(timeline_df, style=Style(title=title, chart_type=constants.timeline_line_type,
                                                         plotly_plot_mode=constants.plotly_plot_mode,
                                                         line_shape=constants.timeline_lineshape,
                                                         connect_line_gaps=constants.timeline_connect_line_gaps,
                                                         width=width,
                                                         height=height, scale_factor=1, plotly_webgl=constants.plotly_webgl))

    def plot_bar(self, bar_df=None, title=None, width=constants.chart_width, height=constants.chart_height):
        """Plots a bar chart as a plotly Fig object

        Parameters
        ----------
        bar_df : DataFrame
            Data to be plotted as a bar chart

        title : str
            Title of the chart

        width : int
            Width of plot

        height : int
            Height of plot

        Returns
        -------
        plotly.Fig
        """

        self._check_empty(bar_df)

        style = Style(title=title, chart_type='bar',
                      plotly_plot_mode=constants.plotly_plot_mode, width=width,
                      height=height, scale_factor=1, plotly_webgl=constants.plotly_webgl)

        plot = self._chart.plot(bar_df, style=style)

        return plot

    def plot_dist(self, dist_df=None, metric=None, title=None, split_by='all', ticker=None, width=constants.chart_width,
                  height=constants.chart_height):
        """Plots the distribution, returning a Plotly Fig object

        Parameters
        ----------
        dist_df : DataFrame
            Distribution

        metric : str
            Metric to be plotted

        title : str
            Title of the chart

        split_by : str
            'all' - collect all results together
            'side' - split by side of trade

        ticker : str
            Asset ticker(s)

        width : int
            Width of plot

        height : int
            Height of plot

        Returns
        -------
        plotly.Fig
        """
        logger = LoggerManager.getLogger(__name__)

        self._check_empty(dist_df)

        chart_type = None

        try:
            if ticker is None:
                ticker = title[0:6]
        except:
            ticker = 'dist'

        # Add lines for bid/ask only this exists in the underlying data
        x_y_line = []

        try:
            bid = (dist_df['Bid']).values[0]
            ask = (dist_df['Ask']).values[0]
            bid_max = dist_df.max(axis=0).max()
            ask_max = bid_max

            x_y_line = [[(bid, 0), (bid, bid_max)], [(ask, 0), (ask, ask_max)]]

            dist_df = dist_df.drop(['Bid', 'Ask'], axis=0)
        except Exception as e:
            pass
            # print(str(e))

        # Get the bid/ask values (and co-ordinates), so they can be added to the plot as additional lines later
        if split_by == 'side':

            if not(dist_df.empty):
                pdf_label_list = ['Norm-PDF:', 'KDE-PDF:']
                hist_label = 'Histogram: ' + ticker

                # Only select those PDF and histogram columns which are present (will not always have both buy and sell trades
                # in the same sample)
                cols_plot = []
                color = [];
                # x_y_line = [];
                linewidth = []

                chart_type = []

                sides = [-1, 1]

                sides_colour = {-1: 'red', 1: 'green'}
                # dash_type = {'Norm-PDF: ' + ticker: 'line', 'KDE-PDF: ' + ticker: 'dash'}
                dash_type = {'Norm-PDF:': 'line', 'KDE-PDF:': 'dash'}

                # Remove .0 from column names
                dist_df.columns = [x.replace('.0', '') for x in dist_df.columns]

                for i in sides:
                    try:
                        # PDF plots properties
                        for pdf_label in pdf_label_list:

                            pdf = pdf_label + ' ' + str(i)

                            if pdf in dist_df.columns:
                                cols_plot.append(pdf);
                                color.append(sides_colour[i]);
                                chart_type.append(dash_type[pdf_label]);
                                linewidth.append(1)

                        # histogram plots properties
                        hist = hist_label + ' ' + str(i)

                        if hist in dist_df.columns:
                            cols_plot.append(hist);
                            color.append(sides_colour[i]);
                            chart_type.append('scatter');
                            linewidth.append(3)
                    except Exception as e:
                        pass
                        # print(str(e))

                # Select PDF and histogram series only
                dist_df = dist_df[cols_plot]

            style = Style(title=ticker, subplots=False, color=color,
                        linewidth=linewidth, x_title=metric.replace('_', ' ') + ' (bp)', connect_line_gaps=True,
                        x_y_line=x_y_line, y_title='Notional', plotly_plot_mode=constants.plotly_plot_mode,
                        width=width, height=height, scale_factor=1, plotly_webgl=constants.plotly_webgl)
        else:
            style = Style(title=title, x_title=metric.replace('_', ' ') + ' (bp)', connect_line_gaps=True,
                          x_y_line=x_y_line,
                          y_title='Notional', plotly_plot_mode=constants.plotly_plot_mode,
                          width=width, height=height, scale_factor=1, plotly_webgl=constants.plotly_webgl)

        if 'Bid' in dist_df.columns: dist_df = dist_df.drop('Bid', axis=1)
        if 'Ask' in dist_df.columns: dist_df = dist_df.drop('Ask', axis=1)

        if title is None:
            title = ''

        logger.debug('Plotting distribution ' + title)

        plot = self._chart.plot(dist_df, style=style, chart_type=chart_type)

        logger.debug('Rendered distribution ' + title)

        return plot

    # TODO incomplete
    def plot_scatter(self, trade_order_df=None, metric=None, title=None, notional_field='executed_notional', split_by='all'):

        scatter_df = trade_order_df

        if not(isinstance(metric, list)):
            metric = [metric]
        else:
            notional_series = trade_order_df[notional_field]

        # TODO
        self._check_empty(scatter_df)

        style = Style(title=title, chart_type='scatter',
                        plotly_plot_mode=constants.plotly_plot_mode, width=constants.chart_width,
                        bubble_series = {'buy trade': notional_series,
                           'sell trade': notional_series},
                        height=constants.chart_height, scale_factor=1, plotly_webgl=constants.plotly_webgl)

        plot = self._chart(scatter_df, style=style)

        return plot


    def generate_candlesticks(self, market_downsampled_df, chart_type=constants.chart_type_candlesticks):
        """Creates a downsampled version of market data ready for ploting, alongside candlesticks/OHLC, which summarise
        the market moves by marking OHLC prices.

        Parameters
        ----------
        market_downsampled_df : DataFrame
            Market data, typically containing the mid price for a ticker, which has been downsampled for plotting

        chart_type : str
            Chart type to render (eg. 'ohlc' or 'candlesticks')

        Returns
        -------
        pd.DataFrame, plotly.Fig
        """

        if chart_type == 'candlesticks':
            fig_candle = figure_factory.create_candlestick(market_downsampled_df['open'],
                                                           market_downsampled_df['high'],
                                                           market_downsampled_df['low'],
                                                           market_downsampled_df['close'],
                                                           dates=market_downsampled_df['close'].index)
        elif chart_type == 'ohlc':
            fig_candle = figure_factory.create_ohlc(market_downsampled_df['open'],
                                                    market_downsampled_df['high'],
                                                    market_downsampled_df['low'],
                                                    market_downsampled_df['close'],
                                                    dates=market_downsampled_df['close'].index)
        else:
            raise Exception("This is an invalid chart type " + chart_type)

        return fig_candle

    def calculate_markout(self, trade_time, market_df, trade_order_df):
        """Using cached market and trade data, we create a markout for the period around our specified trade time.

        Parameters
        ----------
        trade_time : datetime
            Date/Time of the trade we want to markout

        market_df : DataFrame
            Contains market data for an asset typically with the mid-price

        trade_order_df : DataFrame
            Contains client trade/order data

        Returns
        -------
        pd.DataFrame
        """

        # Need to get closest trade (as users might not click exactly over the trades)
        # closest_index = int(trade_df.index.get_loc(trade_time, method='nearest'))
        closest_index = self._time_series_ops.closest_date_index(trade_order_df, trade_time)

        # Select only the trades which match the trade time
        trade_order_df = pd.DataFrame(trade_order_df.iloc[closest_index, :]).transpose()

        # Calculate the detail markout
        # result will be a plot of the average drift versus the move around the trades we want
        metric_trade_df, metric_df = \
            self._metric_wide_benchmark_markout.calculate_metric(
                trade_order_df, market_df, bid_benchmark='bid', ask_benchmark='ask', wide_benchmark='mid')

        # Need to transpose it to make it easier to plot
        return metric_df.transpose()

    def generate_table(self, data_frame):
        """Converts a pandas DataFrame into an HTML representation which can displayed by Flask.

        Parameters
        ----------
        data_frame : DataFrame
            Table to be parsed

        Returns
        -------
        str
        """

        logger = LoggerManager.getLogger(__name__)

        SLOW = False

        if constants.gui_table_type == 'html':
            if data_frame is None: return

            # Older implementation (slow given the many for loops) - perhaps use Numba to speed up?
            if SLOW:
                str_data_frame_cols = [str(col) for col in data_frame.columns]
                full_cols = self._util_func.flatten_list_of_lists(['Date', str_data_frame_cols])

                header = [html.Tr([html.Th(str(col)) for col in full_cols])]

                body = []

                for i in range(len(data_frame)):
                    contents = []

                    # create index
                    contents.append(html.Td(data_frame.index[i]))

                    # add the other columns
                    for col in data_frame.columns:
                        contents.append(html.Td(data_frame.iloc[i][col]))

                    body.append(html.Tr(contents))

                logger.info("Table rendered!")

                return html.Table(header + body)

            # Quicker to render as an iFrame
            else:

                if 'side' in data_frame.columns:
                    data_frame['side'] = data_frame['side'].fillna(0).apply(np.int64)

                data_frame.index.name = None
                df_html = '<style>' + self._css + '</style>\n'
                # df_html = r'<link rel="stylesheet" type="text/css" media="screen" href="tcapy.css" />' + '\n'
                df_html += data_frame.to_html(border=0)#, pad=0)

                df_html = df_html.replace(' class="dataframe"', '')
                df_html = df_html.replace('000+00:00', '')
                df_html = df_html.replace('NaN', '')


                return html.Iframe(srcDoc=df_html, width="975px", height="300px", sandbox='',
                                   style={'border': 'thin lightgrey solid', 'padding': '0', 'margin' : '0'},)
        else:
            if data_frame is not None:
                data_frame.insert(loc=0, column='Date', value=data_frame.index)

                # Return data_frame.to_dict('rows')
                return data_frame.to_dict(orient='records', into=OrderedDict)

    def convert_df_csv(self, data_frame):
        """Converts a pandas DataFrame into a string CSV representation which can be used to server CSV files to users.

        Parameters
        ----------
        data_frame : DataFrame
            Table to be output
        Returns
        -------
        str
        """

        if data_frame is None: return

        return data_frame.to_csv(index=True, encoding='utf-8')
